# bites
A playground.

## builds
We use guix as the build orchestrator, delegating to platform build systems (mvn, meson, cargo, node) for the regular experience. This gets us quite a lot:
- interactivity and a normal dev experience by the build systems
- a clean separation across language environments (namely, java calling into rust or C through JNI)
- first class support in guix (provided I use supported build systems, and that dependencies I use are packaged)

As long as the build systems themselves can link against artifacts generated by other build systems (and not have to _drive_ the build themselves) then we should get our dream of building across language boundaries within the same deployable artifact.

We _might_ struggle specifically with java calling into other languages since the development of the java API and the headers are intertwined (that is, we not only have to load a shared object file, but we also have to make sure that they're linked together correctly through java-side declarations). Further, Java has no mechanism to actually confirm that the JNI method signatures actually work until it tries to do it at runtime and crashes. However an easy way to fix that is just to write tests.

The only mitigateable caveat is that updating the source/build of a given package won't be reloaded automatically (within emacs. within the shell there's the prompt hook). However, there is a convenient solution to this that I was already thinking would be the best layout: manifests declared as modules, with the load path containing this repository as the root.

As I switch between one buffer to the other, direnv-mode switches between different envrcs (subprojects will have as input other subprojects), which will cause re-evaluation. We might be able to push this evaluation into a background process, and also do it eagerly (see `./listen.sh` for a first attempt)

