# bites
A playground.

## builds
We use guix as the build orchestrator, delegating to already-integrated platform build systems (maven, meson/cmake, cargo, node, cl-asdf) for builds. This gets us quite a lot:
- interactivity and a normal dev experience by the build systems
- a clean separation across language environments (namely, java calling into rust or C through JNI)
- first class support in guix (provided I use supported build systems, and that dependencies I use are packaged)

As long as the build systems themselves can link against artifacts generated by other build systems (and not have to _drive_ the build themselves) then we should get our dream of building across language boundaries within the same deployable artifact: guix is primarily responsible for cross language, cross platform dependency resolution, and the per-language build systems do the compiling + linking.

We _might_ struggle specifically with java calling into other languages since the development of the java API and the headers are intertwined (that is, we not only have to load a shared object file, but we also have to make sure that they're linked together correctly through java-side declarations). Further, Java has no mechanism to actually confirm that the JNI method signatures actually work until it tries to do it at runtime and crashes. However an easy way to fix that is just to write tests.

The only caveat is that updating the source/build of a given package won't be reloaded automatically (within emacs. within the shell there's the prompt hook). However, there is a convenient solution to this that I was already thinking would be the best layout: manifests declared in each module, with the load path containing this repository as the root.

As I switch between one buffer to the other, direnv-mode switches between different envrcs (subprojects will have as input other subprojects), which will cause re-evaluation. We might be able to push this evaluation into a background process, and also do it eagerly (see `./listen.sh` for a first attempt), though the tradeoff is that we start pounding the store with lots of intermediates on every save.

## guix module layout
- root
  - manifest.scm - has only things that are needed globally (inotify-tools, direnv). may not refer to submanifests (in fact, it's usually sourced by them)
  - all.scm - refers to all buildable artifacts, can be used for a quick "build + test everything in this repo"
  - example1
    - guix.scm - package definition of example1
    - manifest.scm - if it exists, wraps the development manifest of whatever's in the guix.scm definition with auxiliary things needed (should be rare)
  - example2
    - guix.scm - package definition of example2, depends on example1

If these become anything deployable, they will be moved out of tree into their own repos, with the packaging (and so, development profiles) defined in a guix channel so that they can be referred to from where ever.

### further ideas
instead of using direnv to trigger builds as we jump between projects in the UI, why not just defer them until we actually build/test? e.g. guix shell example2 -- cd example2; mvn build example2

The only time we need them is when we're compiling. This significantly minimizes the amount of intermediates in the store (nothing stops us from running the build system directly).
